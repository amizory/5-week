# Основы виртуализации и контейнеризации

* [Основы Docker](#Основы-Docker)
* [Основны Containers orchestration](#Основны-Containers-orchestration )
* [Основы Kubernetes](#Основы-Kubernetes)
* [kubectl](#kubectl)

## <a id="Основы-Docker">Основы Docker</a>

```txt
1 - Компоненты Docker.
2 - Установка и настройка Docker на Linux, Windows и Mac.
3 - Понятие образа и контейнера.
4 - Синтаксис Dockerfile.
5 - Docker Registry, публичные и приватные Registry. 
6 - Docker-compose.
7 - Использование Docker в CI/CD пайплайнах.
8 - Dockerfile Best Practice.
```

### Notice-1

```txt
1 - Из каких компонентов состоит docker?

->
```

```txt
2 - Что такое образ? 

->
```

```txt
3 - Что такое контейнер?

->
```

```txt
4 - Что такое Docker Registry? 

->
```

```txt
5 - Как скачать образ с приватного Docker Registry, требующего логин/пароль или токен?

->
```

```txt
6 - Что такое Docker-compose?

->  
```

```txt
7 - Как запустить Docker контейнер?

->  
```

```txt
8 - Как выполнить команду внутри Docker контейнера?

->  
```

```txt
9 - Как посмотреть логи Docker контейнера?
->  
```

### Intern-1

```txt
1 - Что такое слои в Docker?

->
```

```txt
2 - Чем директива ADD отличается от COPY?

->
```

```txt
3 - Чем директива ARG отличается от ENV?

->
```

```txt
4 - Чем директива CMD отличается от ENTRYPOINT? Могут ли они использоваться вместе?


->
```

```txt
5 - Можно ли (и если да, то как) переопределить директивы CMD и ENTRYPOINT из Dockerfile
    при запуске контейнера? 

->  
```

```txt
6 - Как подключить volume к контейнеру? Какие типы volume`ов поддерживает Docker?

->  
```

### Advanced-1

```txt
1 - Какие типы сокетов поддерживает docker cli?

->
```

```txt
2 - Какие Best Practice надо следовать при написание Dockerfile? 

->
```

```txt
3 - Что делает команда docker commit?

->
```

```txt
4 - Что такое Copy on Write?

->
```

## <a id="Основны-Containers-orchestration ">Основны Containers orchestration</a>

```txt
1 - Понятие Containers orchestration.
2 - Kubernetes, что это такое, зачем и где используется.
3 - Понятие кластера.
```

### Notice-2

```txt
1 - Что такое Containers orchestration? 

->  Контейнерная оркестрация (Containers orchestration) - это автоматизация управления
    контейнерами, включая их запуск, масштабирование, мониторинг и управление зависимостями
    между ними. Это позволяет эффективно управлять большим количеством контейнеров, которые
    могут работать на разных хостах, и обеспечивает высокую доступность и масштабируемость
    приложений.

    Например, если у вас есть веб-приложение, которое состоит из нескольких микросервисов,
    таких как база данных, сервер приложений и сервер фронтэнда, контейнерная оркестрация
    может автоматически запускать и масштабировать контейнеры для каждого микросервиса, а
    также управлять взаимодействием между ними.
    - Некоторые примеры контейнерной оркестрации включают:
    - Автоматическое развертывание контейнеров на разных хостах
    - Масштабирование контейнеров в зависимости от нагрузки
    - Мониторинг состояния контейнеров и автоматическое восстановление в случае сбоя
    - Управление сетевыми соединениями между контейнерами
    - Обеспечение безопасности и аутентификации контейнеров
```

```txt
2 - Какие есть примеры данного класса ПО?

->  - Kubernetes: один из наиболее популярных инструментов контейнерной оркестрации,
    который позволяет автоматически развертывать, масштабировать и управлять контейнерами.
    - Docker Swarm/Apache Mesos: инструмент контейнерной оркестрации, который
    позволяет автоматически развертывать и масштабировать контейнеры в кластере.
    - Red Hat OpenShift: платформа контейнерной оркестрации, которая позволяет автоматически
    развертывать, масштабировать и управлять контейнерами.
    - Rancher/Nomad: инструмент контейнерной оркестрации, который позволяет автоматически
    развертывать, масштабировать и управлять контейнерами.
    - Google Kubernetes Engine (GKE): сервис контейнерной оркестрации, который позволяет
    автоматически развертывать, масштабировать и управлять контейнерами в облаке Google Cloud.
    - Amazon Elastic Container Service (ECS): сервис контейнерной оркестрации, который
    позволяет автоматически развертывать, масштабировать и управлять контейнерами в облаке
    Amazon Web Services.
```

```txt
3 - Что такое кластер (в общем смысле)?

->  Кластер (англ. cluster) - это группа компьютеров или узлов, которые работают вместе
    как единая система, чтобы обеспечить высокую доступность, масштабируемость и
    производительность.

    В общем смысле, кластер - это совокупность нескольких машин, которые объединены
    вместе для достижения общей цели. Кластеры могут быть использованы для различных
    целей, таких как:
    - Обработка больших данных
    - Выполнение сложных вычислений
    - Обеспечение высокой доступности и отказоустойчивости
    - Масштабирование приложений
    - Обеспечение безопасности и защиты данных

    Кластеры могут состоять из нескольких машин, которые могут быть физическими или
    виртуальными, и которые могут быть расположены в одном месте или распределены по
    нескольким местам.

    В контексте контейнерной оркестрации, кластер - это группа машин, на которых запускаются
    контейнеры, и которые управляются оркестратором для обеспечения высокой доступности и
    масштабируемости приложений.
```

### Intern-2/Advanced-2

```txt
1 - Какие есть альтернативы Kubernetes?

->  - Kubernetes является одним из наиболее популярных инструментов контейнерной оркестрации,
    но существуют альтернативы, которые могут быть более подходящими для определенных случаев
    использования. Вот альтернативы Kubernetes:

    - Docker Swarm: Docker Swarm - это инструмент контейнерной оркестрации, который позволяет
    автоматически развертывать и масштабировать контейнеры в кластере. Docker Swarm является
    частью платформы Docker и предоставляет простой и легкий способ управления контейнерами.

    - Apache Mesos: Apache Mesos - это инструмент контейнерной оркестрации, который позволяет
    автоматически развертывать и масштабировать контейнеры в кластере. Mesos является более
    старым инструментом, чем Kubernetes, но он все еще широко используется в промышленности.

    - Nomad: Nomad - это инструмент контейнерной оркестрации, который позволяет автоматически
    развертывать и масштабировать контейнеры в кластере. Nomad является более легким и
    простым инструментом, чем Kubernetes, но он все же предоставляет мощные возможности
    управления контейнерами.

    - Rancher: Rancher - это платформа контейнерной оркестрации, которая позволяет
    автоматически развертывать и масштабировать контейнеры в кластере. Rancher предоставляет
    простой и легкий способ управления контейнерами, а также поддерживает несколько
    оркестраторов, включая Kubernetes и Docker Swarm.

    - OpenShift: OpenShift - это платформа контейнерной оркестрации, которая позволяет
    автоматически развертывать и масштабировать контейнеры в кластере. OpenShift
    предоставляет простой и легкий способ управления контейнерами, а также поддерживает
    несколько оркестраторов, включая Kubernetes.

    - Amazon ECS: Amazon ECS - это сервис контейнерной оркестрации, который позволяет
    автоматически развертывать и масштабировать контейнеры в кластере. Amazon ECS является
    частью платформы Amazon Web Services и предоставляет простой и легкий способ управления
    контейнерами.

    - Google Cloud Run: Google Cloud Run - это сервис контейнерной оркестрации, который
    позволяет автоматически развертывать и масштабировать контейнеры в кластере. Google
    Cloud Run является частью платформы Google Cloud и предоставляет простой и легкий
    способ управления контейнерами.
```

## <a id="Основы-Kubernetes">Основы Kubernetes</a>

```txt
1 - Компоненты Kubernetes.
2 - Абстракции Kubernetes.
```

### Notice-3

```txt
1 - Какие компоненты Kubernetes находятся на master-нодах?

->  api-server -> внешний сервер, который обрабатывает запросы api;
    control-manager -> ответственный за развертывание;
    etcd -> база данных, в которой хранится вся информация о кластере, узлах и статусе;
    планировщик -> место, где будут запущены модули (планирование);
    cloud-controller -> взаимодействие с облаком (балансировщик нагрузки, дисковые тома);
```

```txt
2 - Какие компоненты Kubernetes находятся на worker-нодах?

->  kubelet -> мониторинг выполнения задачи на узле;
    proxy -> сетевое подключение и балансировщик нагрузки;
    cadvisior -> планировщик получения информации о состоянии кластера и запущенных процессах;
    pod -> контейнер или контейнеры;

    Approval Cycle

    container -> приложение;
    pod -> объект (модуль);
    scheduler -> планирование нового модуля;
    replicaset -> модуль управления (изменить)
    deploy -> управление репликами, exe pid-env;
    service -> веб-прокси/балансировщик нагрузки;
    etcd -> вся информация (кластер/развертывание/ресурсы/журналы)
```

```txt
3 - Что такое Pod/ReplicaSet/Deployment/Service/Secret/ConfigMap?

->  - Pod: наименьшая единица развертывания в Kubernetes, представляет собой один или
    несколько контейнеров, работающих вместе.
    - ReplicaSet: обеспечивает запуск и управление несколькими копиями подов (репликами)
    для обеспечения высокодоступности и масштабируемости.
    - Deployment: управляет развертыванием подов и обеспечивает обновление версий приложения.
    - Service: обеспечивает доступ к подам через постоянный IP-адрес и DNS-имя, независимо от
    того, где находятся поды в кластере.
    - Secret: хранит конфиденциальную информацию, такую как пароли, ключи и сертификаты, и
    обеспечивает безопасный доступ к ней.
    - ConfigMap: хранит конфигурационные данные, такие как параметры приложения, и
    обеспечивает доступ к ним.

    ReplicaSet:
    Основная цель: обеспечить определенное количество идентичных подов (реплик) в кластере.
    - ReplicaSet управляет только подами, которые были созданы им самим.
    - ReplicaSet не может обновлять поды, он только создает новые или удаляет существующие.
    - ReplicaSet не может масштабировать поды автоматически.

    Deployment:
    Основная цель: обеспечить управление жизненным циклом приложения, включая создание,
    обновление и масштабирование подов.
    - Deployment управляет ReplicaSet, который создает и управляет подами.
    - Deployment может обновлять поды, создавая новые версии ReplicaSet.
    - Deployment может масштабировать поды автоматически.
```

### Intern-3

```txt
1 - Какие типы сервисов есть в kubernetes?

->  - ClusterIP: Этот тип сервиса предоставляет доступ к подам внутри кластера. Сервис
    получает IP-адрес из диапазона кластера и становится доступен только изнутри кластера.
    - NodePort: Этот тип сервиса предоставляет доступ к подам извне кластера через
    определенный порт на каждом узле кластера. Сервис получает IP-адрес из диапазона
    кластера и становится доступен извне кластера через порт, указанный в определении сервиса.
    - LoadBalancer: Этот тип сервиса предоставляет доступ к подам извне кластера через
    балансировщик нагрузки. Сервис получает IP-адрес из диапазона кластера и становится
    доступен извне кластера через балансировщик нагрузки.
    - ExternalName: Этот тип сервиса позволяет указать внешний сервис, который не находится
    в кластере. Сервис не получает IP-адрес из диапазона кластера и не становится доступен
    изнутри кластера.
```

```txt
2 - Что такое DaemonSet/StatefulSet?

->  DaemonSet - это тип ресурса в Kubernetes, который позволяет запускать
    определенное количество подов на каждом узле кластера. DaemonSet гарантирует,
    что на каждом узле кластера будет запущен определенный под, даже если узел
    перезагрузится или будет удален.

    DaemonSet используется для следующих целей:
    - Мониторинг узлов кластера
    - Сбор логов и метрик
    - Обновление конфигурации узлов
    - Запуск агентов безопасности
    DaemonSet имеет следующие характеристики:
    - DaemonSet создает поды на каждом узле кластера
    - DaemonSet гарантирует, что на каждом узле кластера будет запущен определенный под
    - DaemonSet может быть использован для запуска подов с высоким приоритетом

    StatefulSet - это тип ресурса в Kubernetes, который позволяет запускать
    определенное количество подов с сохранением состояния. StatefulSet гарантирует,
    что каждый под будет иметь уникальное имя и будет сохранять свое состояние даже
    после перезапуска.

    StatefulSet используется для следующих целей:
    - Запуск баз данных
    - Запуск сообщественных систем
    - Запуск систем хранения данных
    StatefulSet имеет следующие характеристики:
    - StatefulSet создает поды с уникальными именами
    - StatefulSet гарантирует, что каждый под будет сохранять свое состояние
    - StatefulSet может быть использован для запуска подов с высоким приоритетом
```

```txt
3 - Что такое Persistent Volume?

->  Persistent Volume (PV) - это ресурс в Kubernetes, который представляет собой
    постоянное хранилище данных. PV позволяет сохранять данные даже после того, как
    под, который использовал эти данные, был удален или перезапущен.

    PV может быть создан из различных источников, таких как:
    - Локальный диск
    - Сеть хранения данных (SAN)
    - Облачное хранилище (например, Amazon S3)
    - Distributed File System (DFS)
    - HostPath (директория на хост-машине)

    PV имеет следующие характеристики:
    - PV представляет собой постоянное хранилище данных
    - PV может быть использован для сохранения данных приложения
    - PV может быть использован для обеспечения доступа к данным из нескольких подов
    - PV может быть использован для обеспечения доступа к данным из разных namespace

    PV может быть доступен через различные интерфейсы, такие как:
    - NFS (Network File System)
    - Ceph
    - GlusterFS
    - iSCSI

    - ReadWriteOnce (RWO): Этот режим позволяет только одному поду читать и записывать данные
    в PV. Если несколько подов пытаются использовать PV в этом режиме, они получат ошибку.
    - ReadOnlyMany (ROX): Этот режим позволяет нескольким подам читать данные из PV, но никто
    не может записывать данные в PV.
    - ReadWriteMany (RWX): Этот режим позволяет нескольким подам читать и записывать
    данные в PV.
    - ReadWriteOncePod (RWOP) том может быть смонтирован как чтение-запись одним Pod.
    Используйте режим доступа ReadWriteOncePod, если вы хотите гарантировать, что только
    один pod во всем кластере может читать этот PVC или записывать в него.

    Эти accessModes определяют, как поды могут использовать PV, и помогают обеспечить
    безопасность и целостность данных.
    - Например, если вы хотите использовать PV для хранения конфигурационных файлов,
    вы можете использовать режим ReadOnlyMany (ROX), чтобы несколько подов могли
    читать конфигурационные файлы, но никто не мог изменять их.
    - Если вы хотите использовать PV для хранения данных, которые должны быть доступны только
    одному поду, вы можете использовать режим ReadWriteOnce (RWO).
    - Если вы хотите использовать PV для хранения данных, которые должны быть доступны
    нескольким подам и могут быть изменены, вы можете использовать режим ReadWriteMany (RWX).

    - Retain: Этот режим сохраняет данные в PV даже после того, как PV будет удален.
    Данные будут сохранены на хост-машине, где PV был создан.
    - Delete: Этот режим удаляет данные в PV после того, как PV будет удален. Данные
    будут удалены с хост-машине, где PV был создан.
    - Recycle: Этот режим удаляет данные в PV и затем создает новый PV с теми же
    характеристиками. Этот режим не рекомендуется использовать, поскольку он может
    привести к потере данных.

    Эти persistentVolumeReclaimPolicy определяют, что произойдет с данными в PV после
    того, как PV будет удален.
    - Например, если вы хотите сохранить данные в PV даже после того, как PV
    будет удален, вы можете использовать режим Retain.
    - Если вы хотите удалить данные в PV после того, как PV будет удален, вы можете
    использовать режим Delete.
    - Если вы хотите удалить данные в PV и затем создать новый PV с теми же
    характеристиками, вы можете использовать режим Recycle.

```

## Advanced-3

```txt
1 - Что такое Service Mesh?


->  Service Mesh - это архитектурный подход к управлению микросервисами в
    распределенной системе. Он представляет собой слой инфраструктуры, который
    обеспечивает управление и мониторинг взаимодействия между микросервисами.

    Service Mesh обеспечивает следующие функции:
    - Управление трафиком: Service Mesh позволяет управлять потоком трафика между
    микросервисами, включая маршрутизацию, балансировку нагрузки и ограничение скорости.
    - Мониторинг и трассировка: Service Mesh позволяет мониторить и трассировать
    взаимодействие между микросервисами, включая сбор метрик и логов.
    - Безопасность: Service Mesh обеспечивает безопасность взаимодействия между
    микросервисами, включая шифрование и аутентификацию.
    - Управление конфигурацией: Service Mesh позволяет управлять конфигурацией
    микросервисов, включая управление версиями и конфигурацией окружения.

    Service Mesh состоит из следующих компонентов:
    - Sidecar: Sidecar - это контейнер, который запускается вместе с микросервисом
    и обеспечивает управление и мониторинг взаимодействия между микросервисами.
    - Service Mesh обычно реализуется путем предоставления каждому экземпляру
    сервиса экземпляра прокси, который называется Sidecar. Sidecar обрабатывают коммуникации
    между сервисами, производят мониторинг и устраняют проблемы безопасности, то есть все,
    что может быть абстрагировано от отдельных сервисов.
    - Control Plane: Control Plane - это компонент, который управляет Sidecar и
    обеспечивает управление и мониторинг взаимодействия между микросервисами.
    - Data Plane: Data Plane - это компонент, который обеспечивает передачу данных
    между микросервисами.

    Service Mesh имеет следующие преимущества:
    - Улучшение управления: Service Mesh обеспечивает улучшенное управление
    взаимодействием между микросервисами.
    - Улучшение безопасности: Service Mesh обеспечивает улучшенную безопасность
    взаимодействия между микросервисами.
    - Улучшение мониторинга: Service Mesh обеспечивает улучшенный мониторинг
    взаимодействия между микросервисами.

    Service Mesh имеет следующие недостатки:
    - Сложность: Service Mesh может быть сложным для установки и управления.
    - Дополнительная нагрузка: Service Mesh может добавить дополнительную нагрузку на систему.

    Примеры Service Mesh:
    - Istio от Google, IBM и Lyft, на данный момент является самый известной Service
    Mesh-архитектурой. А Kubernetes, который изначально разрабатывался в Google,
    сейчас является единственным фреймворком для оркестрации контейнеров, который
    поддерживается Istio.
    - Linkerd: Linkerd - это Service Mesh, который обеспечивает управление и мониторинг
    взаимодействия между микросервисами.
    - Consul: Consul - это Service Mesh, который обеспечивает управление и мониторинг
    взаимодействия между микросервисами.
```

```txt
2 - Какие типы секретов есть в kubernetes?

->  Opaque Secret: Этот тип секрета используется для хранения конфиденциальных данных,
    таких как пароли, ключи и сертификаты. Opaque Secret хранит данные в виде
    base64-кодированного строки.

    kubernetes.io/dockerconfigjson Secret: Этот тип секрета используется для хранения
    конфигурации Docker Registry. Этот тип секрета хранит данные в виде JSON-объекта.

    Также есть еще один тип секрета, который называется kubernetes.io/service-account-token
    Secret, но он используется только для сервис-аккаунтов и не может быть создан вручную.

    apiVersion: v1
    kind: Secret
    metadata:
        name: my-secret
    type: Opaque
    data:
        username: <base64 encoded username>
        password: <base64 encoded password>
```

```txt
3 - Как обеспечить отказоустойчивость кластера kubernetes?

->  - Распределение узлов: Распределите узлы кластера по нескольким физическим
    серверам или виртуальным машинам, чтобы обеспечить высокую доступность. 
    (Создание узлов/Конфигурация узлов)
    - Использование контроллера: Используйте контроллер для управления узлами и
    обеспечения отказоустойчивости.
    - Использование реплик: Используйте реплики для обеспечения отказоустойчивости приложений.
    - Использование сервисов: Используйте сервисы для обеспечения доступа к приложениям и
    обеспечения отказоустойчивости.
    - Использование Persistent Volume: Используйте Persistent Volume для обеспечения
    сохранения данных приложений.
    - Использование Backup и Restore: Используйте Backup и Restore для обеспечения
    сохранения данных приложений и восстановления их в случае отказа.
    - Использование мониторинга и логирования: Используйте мониторинга и логирования
    для обеспечения контроля над работой кластера и выявления проблем.
    - Использование автоматического масштабирования: Используйте автоматическое
    масштабирование для обеспечения масштабирования кластера в зависимости от нагрузки.
```

```txt
4 - Как можно разграничить доступ к нейспейсам/объектам внутри кластера?

->  - Role-Based Access Control (RBAC): RBAC - это механизм управления доступом,
    который позволяет назначать роли пользователям или группам, определяя их права
    доступа к ресурсам кластера.
    - Service Accounts: Service Accounts - это специальные учетные записи, которые
    используются для аутентификации и авторизации сервисов внутри кластера.
    - Network Policies: Network Policies - это механизм управления доступом к сетям,
    который позволяет определять правила доступа к ресурсам кластера.
    - Namespace-Based Access Control: Namespace-Based Access Control - это механизм
    управления доступом, который позволяет определять права доступа к ресурсам кластера
    на основе нейспейсов.

    RBAC
     - RBAC - это механизм управления доступом, который позволяет назначать роли
     пользователям или группам, определяя их права доступа к ресурсам кластера.
     - Роли: Роли - это набор прав доступа, которые определяют, что пользователь или
     группа могут делать с ресурсами кластера.
     - Ролебиндинги: Ролебиндинги - это связь между ролью и пользователем или группой,
     которая определяет права доступа пользователя или группы к ресурсам кластера.

    apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
        name: my-role
    rules:
    - apiGroups: ["*"]
      resources: ["*"]
      verbs: ["*"]
---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
        name: my-rolebinding
    roleRef:
        name: my-role
        kind: Role
    subjects:
    - kind: User
      name: my-user
      namespace: my-namespace

    Service Accounts
     - Service Accounts - это специальные учетные записи, которые используются для
     аутентификации и авторизации сервисов внутри кластера.
     - Service Account: Service Account - это учетная запись, которая используется для
     аутентификации и авторизации сервисов внутри кластера.
     - Service Account Token: Service Account Token - это токен, который используется
     для аутентификации и авторизации сервисов внутри кластера.

    Network Policies
     - Network Policies - это механизм управления доступом к сетям, который позволяет
     определять правила доступа к ресурсам кластера.
     - Network Policy: Network Policy - это набор правил, которые определяют доступ к
     ресурсам кластера.
     - Network Policy Ingress: Network Policy Ingress - это набор правил, которые определяют
     доступ к ресурсам кластера извне кластера.

    Namespace-Based Access Control
     - Namespace-Based Access Control - это механизм управления доступом, который позволяет
     определять права доступа к ресурсам кластера на основе нейспейсов.
     - Namespace: Namespace - это логический раздел кластера, который содержит ресурсы
     кластера.
     - Namespace-Based Access Control: Namespace-Based Access Control - это механизм
     управления доступом, который позволяет определять права доступа к ресурсам кластера
     на основе нейспейсов.
```

## <a id="kubectl">kubectl</a>

```txt
1 - Подключение к кластеру.
2 - Основные команды.
```

### Notice-4

```txt
1 - Как подключиться к кластеру с помощью kubectl?

->  Чтобы подключиться к кластеру с помощью kubectl, необходимо указать контекст, в котором 
    находится кластер. Это можно сделать двумя способами

    1-kubectl config use-context <имя-контекста>
    2-kubectl --context=<имя-контекста> <команда>
    3-kubectl --kubeconfig=/path/to/config get pods
    4-kubectl config set-cluster <имя-кластера> --server=<адрес-сервера> 
      --insecure-skip-tls-verify
    5-kubectl config set-credentials <имя-пользователя> --token=<токен>
    6-kubectl config set-context my-context --cluster=my-cluster --user=my-user
    7-export KUBECONFIG=/path/to/config
```

```txt
2 - Как вывести список подов в неймпейсе по умолчанию?

->  kubectl get pods -n default -o wide/json, смотря какой у нас ns по умолчанию
```

```txt
    3 - Как установить неймспейс по умолчанию?

->  kubectl config set-default-namespace <имя-неймспейса>
    kubectl config set-default-namespace --all <имя-неймспейса>
    kubectl config set-default-namespace --cluster=<имя-кластера> <имя-неймспейса>
    kubectl config set-context --current --namespace=<имя-неймспейса>
    kubectl config set-context <имя-контекста> --namespace=<имя-неймспейса>
    kubectl config view
    kubectl config set --namespace=<имя-неймспейса>
    export KUBE_NAMESPACE=<имя-неймспейса>
    ~/.kube/config
        apiVersion: v1
        kind: Config
        preferences:
            namespace: my-namespace
```

```txt
4 - Что такое kubectl profile?

->  kubectl profile - это функция в kubectl, которая позволяет создавать и
    управлять несколькими профилями конфигурации. Профиль конфигурации - это
    набор настроек, которые определяют, как kubectl взаимодействует с кластером Kubernetes.

    Профиль конфигурации может включать в себя следующие элементы:
        - Контекст: определяет, какой кластер Kubernetes использовать.
        - Неймспейс: определяет, какой неймспейс использовать по умолчанию.
        - Пользователь: определяет, какой пользователь использовать для аутентификации.
        - Сервер: определяет, какой сервер Kubernetes использовать.
        - Токен: определяет, какой токен использовать для аутентификации.
    Профили конфигурации можно использовать для различных целей, таких как:
        - Разделение доступа к разным кластерам Kubernetes.
        - Управление доступом к разным неймспейсам.
        - Управление доступом к разным пользователям.
        - Управление конфигурацией для разных окружений (например, разработка,
        тестирование, производство).

    kubectl profile позволяет создавать, редактировать и удалять профили конфигурации

    kubectl config create-profile dev --context=my-dev-cluster 
    --namespace=my-dev-namespace --user=my-dev-user
    -----------------------------------------------------------
    kubectl config create-profile test --context=my-test-cluster
    --namespace=my-test-namespace --user=my-test-user
    -----------------------------------------------------------
    kubectl config use-profile dev
    kubectl config use-profile test
```

### Intern-4

```txt
1 - Какие есть форматы вывода?

->  kubectl поддерживает несколько форматов вывода, которые можно использовать
    для вывода информации о ресурсах Kubernetes

    1-wide: Этот формат вывода показывает дополнительную информацию о ресурсах,
            такую как IP-адреса, порты и т. д.
            kubectl get pods -o wide
    2-yaml: Этот формат вывода показывает информацию о ресурсах в формате YAML.
            kubectl get pods -o yaml
    3-json: Этот формат вывода показывает информацию о ресурсах в формате JSON.
            kubectl get pods -o json
    4-jsonpath: Этот формат вывода позволяет вывести информацию о ресурсах в
            формате JSON, используя выражения JSONPath.
            kubectl get pods -o jsonpath='{.items[0].metadata.name}'
    5-name: Этот формат вывода показывает только имена ресурсов.
            kubectl get pods -o name
    6-annotations: Этот формат вывода показывает аннотации ресурсов.
            kubectl get pods -o annotations
    7-labels: Этот формат вывода показывает метки ресурсов.
            kubectl get pods -o labels
```

```txt
2 - Как вывести детальное описание объекта в консоль с помощью kubectl?

->  kubectl describe pods/nodes/deploy/svc/ingress/ns/pv/sts/pvc
    Например, можно использовать опцию -f для вывода информации в формате YAML или JSON
        kubectl describe pod <имя-пода> -f yaml
    Также можно использовать опцию -l для вывода информации о ресурсах,
    которые соответствуют определенным меткам.
        kubectl describe pod -l app=<имя-приложения>
```

```txt
3 - Как отредактировать объект с помощью kubectl?

->  kubectl edit pods/nodes/deploy/svc/ingress/ns/pv/sts/pvc
    Также можно использовать команду kubectl patch для редактирования
    объектов. Эта команда позволяет редактировать объекты, используя JSON-патч.
        kubectl patch deployment <имя-деплоймента> -p '{"spec":{"replicas":3}}'
    Например, можно использовать опцию -f для редактирования файла в формате YAML или JSON.
        kubectl patch deployment <имя-деплоймента> -f yaml -p '{"spec":{"replicas":3}}'

    1-kubectl apply -f <имя-файла> --prune
    2-kubectl patch <имя-объекта> -p '{"spec":{"replicas":3}}'
    3-kubectl edit <имя-объекта> -o yaml
    4-kubectl replace -f <имя-файла>
    5-kubectl annotate <имя-объекта> <имя-аннотации>=<значение-аннотации>
    6-kubectl label <имя-объекта> <имя-метки>=<значение-метки>
```

### Advanced-4

```txt
1 - Как с помощью kubectl вывести поды с определённым значением лейбла? 

->  Чтобы вывести поды с определённым значением лейбла с помощью kubectl,
    можно использовать команду
    kubectl get pods -l app=my-app
    kubectl get pods -l app!=my-app
    kubectl get pods -l app=my-app -l env=
    kubectl get pods -l app in (my-app,my-app2)
    kubectl get pods -l app notin (my-app,my-app2)
```
